import{_ as e,o as a,c as t,U as r}from"./chunks/framework.489e5108.js";const u=JSON.parse('{"title":"GAN","description":"","frontmatter":{},"headers":[],"relativePath":"4.人工智能/4.6.5.3.5GAN.md","filePath":"4.人工智能/4.6.5.3.5GAN.md","lastUpdated":1696176798000}'),p={name:"4.人工智能/4.6.5.3.5GAN.md"},n=r('<h1 id="gan" tabindex="-1">GAN <a class="header-anchor" href="#gan" aria-label="Permalink to &quot;GAN&quot;">​</a></h1><p>这篇论文画风都和前面的几篇完全不一样，因为他的任务是生成，本篇文章将作为可选的拓展阅读。</p><p>比如说生成一些虚拟的 vtuber 他也是完全办得到的，首先留下经典的文章</p><p><a href="https://arxiv.org/abs/1406.2661" target="_blank" rel="noreferrer">Generative Adversarial Networks</a></p><p>GAN 的基本原理其实非常简单，这里以生成图片为例进行说明。假设我们有两个网络，G（Generator）和 D（Discriminator）。正如它的名字所暗示的那样，它们的功能分别是：</p><ul><li>G 是一个生成图片的网络，它接收一个随机的噪声 z，通过这个噪声生成图片，记做 G (z)。</li><li>D 是一个判别网络，判别一张图片是不是 “真实的”。它的输入参数是 x，x 代表一张图片，输出 D（x）代表 x 为真实图片的概率，如果为 1，就代表 100% 是真实的图片，而输出为 0，就代表不可能是真实的图片。</li></ul><p>在训练过程中，生成网络 G 的目标就是尽量生成真实的图片去欺骗判别网络 D。而 D 的目标就是尽量把 G 生成的图片和真实的图片分别开来。这样，G 和 D 构成了一个动态的 “博弈过程”。</p><p>最后博弈的结果是什么？在最理想的状态下，G 可以生成足以 “以假乱真” 的图片 G (z)。对于 D 来说，它难以判定 G 生成的图片究竟是不是真实的，因此 D (G (z)) = 0.5。</p><p>其实就是一个骗一个验证。</p><p>提到他我就想提到另一个算法叫 VAE，你可以对比一下两者的相同点和不同点</p><p>同时，数学推导要从极大似然估计考虑起！</p><p><a href="https://zhuanlan.zhihu.com/p/266677860" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/266677860</a></p>',12),o=[n];function _(s,i,l,c,h,G){return a(),t("div",null,o)}const f=e(p,[["render",_]]);export{u as __pageData,f as default};
