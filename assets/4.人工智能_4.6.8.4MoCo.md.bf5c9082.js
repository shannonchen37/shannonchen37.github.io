import{_ as o,o as a,c as t,U as r}from"./chunks/framework.489e5108.js";const _=JSON.parse('{"title":"MoCo","description":"","frontmatter":{},"headers":[],"relativePath":"4.人工智能/4.6.8.4MoCo.md","filePath":"4.人工智能/4.6.8.4MoCo.md","lastUpdated":1696176798000}'),s={name:"4.人工智能/4.6.8.4MoCo.md"},n=r('<h1 id="moco" tabindex="-1">MoCo <a class="header-anchor" href="#moco" aria-label="Permalink to &quot;MoCo&quot;">​</a></h1><h1 id="提出背景" tabindex="-1">提出背景 <a class="header-anchor" href="#提出背景" aria-label="Permalink to &quot;提出背景&quot;">​</a></h1><p>MoCo 是 Inst Disc 的改进工作，那我们自然要先看一下 Inst Disc 有什么不足</p><h2 id="_1-memory-bank-过大-不能应用在更大的数据集上" tabindex="-1">1.Memory Bank 过大，不能应用在更大的数据集上 <a class="header-anchor" href="#_1-memory-bank-过大-不能应用在更大的数据集上" aria-label="Permalink to &quot;1.Memory Bank 过大，不能应用在更大的数据集上&quot;">​</a></h2><p>因为其字典的数据类型，导致计算开销会加大</p><h2 id="_2-动量更新并不能完全解决特征一致性差的问题" tabindex="-1">2. 动量更新并不能完全解决特征一致性差的问题 <a class="header-anchor" href="#_2-动量更新并不能完全解决特征一致性差的问题" aria-label="Permalink to &quot;2.动量更新并不能完全解决特征一致性差的问题&quot;">​</a></h2><p>即使使用了动量更新的方式，同一个特征前后被调用的跨度也还是很长，一致性依旧不够</p><h2 id="_3-nceloss-负样本分类不合理的问题" tabindex="-1">3.NCEloss 负样本分类不合理的问题 <a class="header-anchor" href="#_3-nceloss-负样本分类不合理的问题" aria-label="Permalink to &quot;3.NCEloss 负样本分类不合理的问题&quot;">​</a></h2><p>NCE 把<strong>所有负样本都视作一样的</strong>，但实际上负样本<strong>并不能被完全归为一类</strong></p><p>举个例子：我现在的正样本是<strong>猫猫</strong>，然后有两个负样本是<strong>狗勾</strong>和<strong>汽车</strong>，那<strong>猫猫</strong>肯定跟<strong>狗勾</strong>更相近，跟<strong>汽车</strong>更不相似，也就是说<strong>狗</strong>的得分虽然低于<strong>猫</strong>，但是一定要高于<strong>汽车</strong>，<strong>而不是像 NCE 那样把狗和车打成一类</strong>，这样不利于模型学习。</p><p>并且它也不是很灵活，下文细讲</p><h3 id="虽然大家应该都懂了-应该吧-但还是贴一下模型总览图。" tabindex="-1">虽然大家应该都懂了（应该吧？），但还是贴一下模型总览图。 <a class="header-anchor" href="#虽然大家应该都懂了-应该吧-但还是贴一下模型总览图。" aria-label="Permalink to &quot;虽然大家应该都懂了（应该吧？），但还是贴一下模型总览图。&quot;">​</a></h3><p>右边就是 memory bank 啦</p><p><img src="https://cdn.xyxsw.site/boxcnKMjslIshEA5SFqc8rbmqoe.png" alt=""></p><h1 id="moco-做出的改进" tabindex="-1">MoCo 做出的改进 <a class="header-anchor" href="#moco-做出的改进" aria-label="Permalink to &quot;MoCo 做出的改进&quot;">​</a></h1><h2 id="_1-针对-memory-bank-过大" tabindex="-1">1. 针对 Memory Bank 过大 <a class="header-anchor" href="#_1-针对-memory-bank-过大" aria-label="Permalink to &quot;1.针对 Memory Bank 过大&quot;">​</a></h2><p>作者使用队列的数据结构去储存这个大字典，因为是先进先出，所以好处是新进来的特征可以把最老的特征替换掉。每次不用把整个字典全部载入，而是用队列形式即可。很简单地解决了这个问题。</p><h2 id="_2-针对动量更新不能完全解决特征一致性差的问题" tabindex="-1">2. 针对动量更新不能完全解决特征一致性差的问题 <a class="header-anchor" href="#_2-针对动量更新不能完全解决特征一致性差的问题" aria-label="Permalink to &quot;2.针对动量更新不能完全解决特征一致性差的问题&quot;">​</a></h2><p>作者提出了一个新的<strong>动量编码器</strong>来替代动量更新。</p><p>动量编码器是独立于原编码器的一个编码器，它的参数是根据原编码器动量更新的，k 和 q 就是指代全部参数了</p><p><img src="https://cdn.xyxsw.site/boxcnFLSP9PtQRkgYgcMwM4idog.png" alt=""></p><p>这样的话就是解码器在缓慢更新，比对特征使用动量更新要更有连续性。</p><h2 id="_3-负样本分类不合理的问题通过替换-infonceloss-解决" tabindex="-1">3. 负样本分类不合理的问题通过替换 infoNCEloss 解决 <a class="header-anchor" href="#_3-负样本分类不合理的问题通过替换-infonceloss-解决" aria-label="Permalink to &quot;3.负样本分类不合理的问题通过替换 infoNCEloss 解决&quot;">​</a></h2><p>下面是 infoNCE loss 的公式，它是 NCE 和交叉熵损失的结合体，长得就很像交叉熵，只是多了个 T。</p><p><a href="https://zhuanlan.zhihu.com/p/149186719" target="_blank" rel="noreferrer">（什么？你看到这了还不会交叉熵？戳这里）</a></p><p><img src="https://cdn.xyxsw.site/boxcnnWI38bkSzeCe5TtVTBCrNh.png" alt=""></p><p>q・k 其实就是各个特征（因为那时候用的都是 transformer 了，这里就是 trnasformer 里的 k 和 q）</p><p>这里分母级数上的<strong> k 是代表负样本的个数，也就是 k=batchsize-1（总样本 - 正样本）</strong>。其实就是<strong>对一个 batch 做 k+1 分类</strong>，并且引入了一个<strong>超参数 T</strong>。它的名字叫做<strong>温度参数</strong>，控制的是 softmax 后得分分布的平滑程度（直观理解，不是很严谨）</p><p>T 越大，损失函数就越对所有负样本<strong>一视同仁</strong>，退化为二分类的 NCEloss；T 越小，损失函数就<strong>越关注一些难分类的特征</strong>，但有时候会出现两张其实都是猫猫的图片，你硬要让模型说猫猫跟猫猫不一样，这也不太好，这个参数要根据数据集情况适中调整。</p><p><img src="https://cdn.xyxsw.site/boxcnhuabU9XzXmVQfu0ruENs83.png" alt=""></p><p><img src="https://cdn.xyxsw.site/boxcnsGpqCNePn2G34GnJqPieBf.png" alt=""></p><p>上面那张是 T 较大的情况，下面是 T 较小的情况（x 轴是各个类别，y 轴是分类得分）</p><p>所谓的灵活性就是指：infoNCE loss 引入了温度参数，这个参数可以帮我们调整训练的难度，T 越大，模型越关注类似的特征，训练也就越难，总之就是非常灵活。</p><h1 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h1><p>总而言之，MoCo 就是基于 Inst Disc 主要做了如上三点改进，模型和参数都是完全不变的。它的核心在于动量编码器和活动大字典。</p><p>能在 imagenet 上达到媲美甚至超越有监督学习的模型的结果，并且可以作为 backbone 很好的拓展应用到多个下游任务上。</p><h1 id="另外" tabindex="-1">另外 <a class="header-anchor" href="#另外" aria-label="Permalink to &quot;另外&quot;">​</a></h1><p>其实 MoCo 有两篇后续工作，MoCo v2 和 MoCo v3，v2 其实就是缝合了后面讲的 SimCLR 的方法，不展开了，V3 留到以后讲。</p>',38),e=[n];function i(h,l,p,c,d,g){return a(),t("div",null,e)}const b=o(s,[["render",i]]);export{_ as __pageData,b as default};
