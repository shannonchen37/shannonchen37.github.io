import{_ as a,o as e,c as t,U as r}from"./chunks/framework.489e5108.js";const f=JSON.parse('{"title":"C 编译器干了什么","description":"","frontmatter":{},"headers":[],"relativePath":"3.编程思维体系构建/3.4.7.3C编译器干了什么.md","filePath":"3.编程思维体系构建/3.4.7.3C编译器干了什么.md","lastUpdated":1696176798000}'),c={name:"3.编程思维体系构建/3.4.7.3C编译器干了什么.md"},o=r('<h1 id="c-编译器干了什么" tabindex="-1">C 编译器干了什么 <a class="header-anchor" href="#c-编译器干了什么" aria-label="Permalink to &quot;C 编译器干了什么&quot;">​</a></h1><h2 id="以-gcc-为例" tabindex="-1">以 gcc 为例 <a class="header-anchor" href="#以-gcc-为例" aria-label="Permalink to &quot;以 gcc 为例&quot;">​</a></h2><p>1、预处理，生成 .i 的文件 [预处理器 cpp]</p><p>2、将预处理后的文件转换成汇编语言，生成文件 .s [编译器 egcs]</p><p>3、有汇编变为目标代码 (机器代码) 生成 .o 的文件 [汇编器 as]</p><p>4、连接目标代码，生成可执行程序 [链接器 ld]</p><h2 id="有啥用" tabindex="-1">有啥用 <a class="header-anchor" href="#有啥用" aria-label="Permalink to &quot;有啥用&quot;">​</a></h2><p>有一天你发现，某一段 C 语言只有几行，但是用了大量的魔法宏定义以及魔法操作以及神奇的元编程。</p><p>你想看懂他，你可能需要学会 gcc -E。将他们都翻译成.i 文件。</p><p>如果有一天你要学习汇编语言，或者说出现了在代码中看不出的 bug，你可能需要翻译成.s 文件</p><h2 id="了解更多" tabindex="-1">了解更多 <a class="header-anchor" href="#了解更多" aria-label="Permalink to &quot;了解更多&quot;">​</a></h2><p>当然不止如此，编译器还承担了优化的过程，有时候同一份代码，经过 O1 和 O2 不同优化可能最后代码都不一样。</p><p>推荐阅读</p><p><a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noreferrer">编译器的工作过程</a></p>',14),_=[o];function p(n,s,i,l,h,d){return e(),t("div",null,_)}const u=a(c,[["render",p]]);export{f as __pageData,u as default};
