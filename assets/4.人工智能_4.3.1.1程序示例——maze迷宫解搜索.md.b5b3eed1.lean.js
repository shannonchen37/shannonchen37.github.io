import{_ as e,I as t,o as l,c as p,j as s,a as n,x as r,U as a}from"./chunks/framework.489e5108.js";const O=JSON.parse('{"title":"程序示例——maze 迷宫解搜索","description":"","frontmatter":{},"headers":[],"relativePath":"4.人工智能/4.3.1.1程序示例——maze迷宫解搜索.md","filePath":"4.人工智能/4.3.1.1程序示例——maze迷宫解搜索.md","lastUpdated":1696176798000}'),c={name:"4.人工智能/4.3.1.1程序示例——maze迷宫解搜索.md"},E=s("h1",{id:"程序示例——maze-迷宫解搜索",tabindex:"-1"},[n("程序示例 ——maze 迷宫解搜索 "),s("a",{class:"header-anchor",href:"#程序示例——maze-迷宫解搜索","aria-label":'Permalink to "程序示例——maze 迷宫解搜索"'},"​")],-1),y=s("div",{class:"warning custom-block"},[s("p",{class:"custom-block-title"},"😋"),s("p",null,"阅读程序中涉及搜索算法的部分，然后运行程序，享受机器自动帮你寻找路径的快乐！ 完成习题")],-1),i={class:"tip custom-block"},F=s("p",{class:"custom-block-title"},"📥",-1),u=a("",15),d=s("li",null,[s("p",null,"在深度优先搜索（DFS）和广度优先搜索（BFS）之间，哪一个会在迷宫中找到更短的路径？"),s("ol",null,[s("li",null,"DFS 将始终找到比 BFS 更短的路径"),s("li",null,"BFS 将始终找到比 DFS 更短的路径"),s("li",null,"DFS 有时（但并非总是）会找到比 BFS 更短的路径"),s("li",null,"BFS 有时（但并非总是）会找到比 DFS 更短的路径"),s("li",null,"两种算法总是能找到相同长度的路径")])],-1),b=s("p",null,"下面的问题将问你关于下面迷宫的问题。灰色单元格表示墙壁。在这个迷宫上运行了一个搜索算法，找到了从 A 点到 B 点的黄色突出显示的路径。在这样做的过程中，红色突出显示的细胞是探索的状态，但并没有达到目标。",-1),m=s("p",null,[s("img",{src:"https://cdn.xyxsw.site/MKtXbfJW3ocWT3xSMK0cwVc4nWf.png",alt:""})],-1),f={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},h={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.685ex",height:"1.62ex",role:"img",focusable:"false",viewBox:"0 -716 1186.6 716","aria-hidden":"true"},A=a("",1),C=[A],D=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("msup",null,[s("mi",null,"A"),s("mo",null,"∗")])])],-1),_=s("p",null,"搜索 —— 可以使用哪一种（或多种，如果可能的话）？",-1),Q={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},B={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.685ex",height:"1.62ex",role:"img",focusable:"false",viewBox:"0 -716 1186.6 716","aria-hidden":"true"},T=a("",1),x=[T],w=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("msup",null,[s("mi",null,"A"),s("mo",null,"∗")])])],-1),g=s("li",null,"只能是贪婪最佳优先搜索",-1),v=s("li",null,"只能是 DFS",-1),q=s("li",null,"只能是 BFS",-1),k={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},S={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.685ex",height:"1.62ex",role:"img",focusable:"false",viewBox:"0 -716 1186.6 716","aria-hidden":"true"},L=a("",1),M=[L],N=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("msup",null,[s("mi",null,"A"),s("mo",null,"∗")])])],-1),z=s("li",null,"可以是 DFS 或 BFS",-1),j=s("li",null,"可能是四种算法中的任何一种",-1),H=s("li",null,"不可能是四种算法中的任何一种",-1),P=s("li",null,[s("p",null,"为什么有深度限制的极大极小算法有时比没有深度限制的极大极小更可取？"),s("ol",null,[s("li",null,"深度受限的极大极小算法可以更快地做出决定，因为它探索的状态更少"),s("li",null,"深度受限的极大极小算法将在没有深度限制的情况下实现与极大极小算法相同的输出，但有时会使用较少的内存"),s("li",null,"深度受限的极大极小算法可以通过不探索已知的次优状态来做出更优化的决策"),s("li",null,"深度限制的极小极大值永远不会比没有深度限制的极大极小值更可取")])],-1),V=s("li",null,[s("p",null,"下面的问题将询问您关于下面的 Minimax 树，其中绿色向上箭头表示 MAX 玩家，红色向下箭头表示 MIN 玩家。每个叶节点都标有其值。")],-1),I=a("",3);function Z(J,R,W,$,G,U){const o=t("Download");return l(),p("div",null,[E,y,s("div",i,[F,s("p",null,[n("本节附件下载 "),r(o,{url:"https://cdn.xyxsw.site/code/1-Lecture.zip"})])]),u,s("ol",null,[d,s("li",null,[b,m,s("p",null,[n("在讲座中讨论的四种搜索算法中 —— 深度优先搜索、广度优先搜索、曼哈顿距离启发式贪婪最佳优先搜索和曼哈顿距离启发式"),s("mjx-container",f,[(l(),p("svg",h,C)),D])]),_,s("ol",null,[s("li",null,[n("只能是"),s("mjx-container",Q,[(l(),p("svg",B,x)),w])]),g,v,q,s("li",null,[n("可能是"),s("mjx-container",k,[(l(),p("svg",S,M)),N]),n(" 或贪婪最佳优先搜索")]),z,j,H])]),P,V]),I])}const X=e(c,[["render",Z]]);export{O as __pageData,X as default};
